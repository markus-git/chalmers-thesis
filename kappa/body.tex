%!TEX root = ../main.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%       oe    
%     .@88    
% ==*88888    
%    88888    
%    88888    
%    88888    
%    88888    
%    88888    
%    88888    
%    88888    
% '**%%%%%%** 
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}

Over the last few years, the amount of traffic going back and forth between devices in the global communications infrastructure has been increasing at a rapid pace. Considering how common connected gadgets have become this might not come as big surprise, but as the steady growth of mobile users and internet of things devices continues~\cite{ericsson2016}, the amount of mobile traffic is projected to become even greater. In fact, global internet traffic is estimated to grow at an average rate of twenty two percent annually, reaching approximately two hundred and fifty million terabytes per month by the end of 2021~\cite{cisco2016}. For the communication infrastructure, the consequence of such a rapid growth rate has been a sharp increase in the demand for computational power on systems that already run under tight latency constraints and with limited memory~\cite{persson2014}, which means computations have to be efficient.

High demands for efficiency under tight latency and resource constraints have greatly influenced the development of embedded systems used for communications infrastructure. A consequence of the strong focus on performance has been that digital signal processing software for embedded systems is typically written in low level C. Low level language, that is, languages of few abstractions, forces developers to focus on low level implementation details rather than any higher level, mathematical specification of the algorithm they are developing. This in turn has the unfortunate consequence of discouraging developers from focusing on other, less immediate aspects of software development such as portability and modularity.




% This thesis consists of two parts. Part I is a general introduction to the field and puts the appended papers into context. Part II contains the appended papers.

\section{Background}

\lipsum[1]

\section{Functional programming}

\lipsum[2]

\section{Domain Specific Languages}

\lipsum[3]

\section{Domain Specific Embedded Languages}

\lipsum[4]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   .--~*teu.
%  dF     988Nx
% d888b   `8888>
% ?8888>  98888F
%  "**"  x88888~
%       d8888*`
%     z8**"`   :
%   :?.....  ..F
%  <""888888888~
%  8:  "888888*
%  ""    "**"`
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Co-Design}

\lipsum[5]

\section{Section about Expression}

\lipsum[1]

\begin{code}
square :: SExp Int32 -> SExp Int32
square a = a * a
\end{code}

\lipsum[1]

\begin{stub}
square :: HExp Int32 -> HExp Int32
square a = a * a
\end{stub}

\lipsum[1]

\begin{stub}
square :: (Multiplicative exp, Type' exp a, Num a) => exp a -> exp a
square a = a * a
\end{stub}

\lipsum[1]

\begin{code}
type Point a = (a, a)

pair :: (Expr exp, Type' exp a, Num a) => Point (exp a) -> Point (exp a) -> exp a
pair (a, b) (u, v) = (a + b) * (u + v)
\end{code}

\lipsum[1]

\begin{code}
dotProd :: (Expr exp, Type' exp a, Num a) => Pull exp a -> Pull exp a -> exp a
dotProd xs ys = forLoop n 0 $ \i s -> s + xs!i * ys!i
  where
    n = min (length xs) (length ys)
\end{code}

\lipsum[1]

\begin{stub}
forLoop :: Syntax exp st => exp Length -> st -> (exp Index -> st -> st) -> st
\end{stub}

\lipsum[1]

\begin{code}
zipWith :: Expr exp => (a -> b -> c) -> Pull exp a -> Pull exp b -> Pull exp c
zipWith f xs ys = fmap (uncurry f) (zip xs ys)

sum :: (Expr exp, Type' exp a, Num a) => Pull exp a -> exp a
sum = fold (+) 0
\end{code}

\lipsum[1]

\begin{code}
scProd :: (Expr exp, Type' exp a, Num a) => Pull exp a -> Pull exp a -> exp a
scProd a b = sum (zipWith (*) a b)
\end{code}

\section{Section about Programs}

\lipsum[1]

\begin{code}
hello :: Software ()
hello = printf "Hello world!\n"
\end{code}

\lipsum[2]

\begin{code}
hello :: Software ()
hello = printf "Hello world!\n"
\end{code}

\lipsum[3]

\begin{code}
reverse :: SArr Int32 -> Software ()
reverse arr =
  do for 0 (len `div` 2) $ \ix ->
       do aix <- getArr arr ix
          ajx <- getArr arr (len - ix)
          setArr arr ix         ajx
          setArr arr (len - ix) aix
  where
    len = length arr
\end{code}

\lipsum[4]

\begin{stub}
reverse :: HArr Int32 -> Hardware ()
\end{stub}

\lipsum[5]

\begin{stub}
reverse :: (Arrays m, Expr (Exp m), Type' (Exp m) Int32) =>
  Arr m (Exp m Int32) -> m ()
\end{stub}

\lipsum[6]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   .x~~"*Weu.
%  d8Nu.  9888c
%  88888  98888
%  "***"  9888%
%       ..@8*"
%    ````"8Weu
%   ..    ?8888L
% :@88N   '8888N
% *8888~  '8888F
% '*8"`   9888%
%   `~===*%"`
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Concluding Remarks}
\label{ch:conc}

\lipsum
