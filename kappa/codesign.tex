%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   .x~~"*Weu.
%  d8Nu.  9888c
%  88888  98888
%  "***"  9888%
%       ..@8*"
%    ````"8Weu
%   ..    ?8888L
% :@88N   '8888N
% *8888~  '8888F
% '*8"`   9888%
%   `~===*%"`
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[../main.tex]{subfiles}
\begin{document}

\chapter{Co-Design}
\label{codesign}

In section~\ref{haskell} we talked about generating C code from our embedded Haskell programs. For the kind of heterogeneous computing that our co-design library aims to describe its not enough to only generate C code; heterogeneous system typically see hardware code interleaved with software code and even components described by the same language can differ by what intrinsic operations they support.

% So, starting with a single Haskell program, our co-design library is designed with three main tasks in mind: generate C code for the software parts, VHDL for the hardware parts, and to generate a combination of software and hardware for the transmission of data between components.

% Furthermore, the software and hardware programs are both extensible in the sense that they support the addition of various intrinsic operations to account for differences between components.

\section{Particular Programs}
\label{program}

While C and VHDL are designed with different tasks in mind, both languages are imperative in nature. Because of this, our co-design library is built on a deep embedding of monads, as a representation of imperative programs. Monads can be thought of as composable descriptions of computations, that is, they provide a means to connect smaller programs into a single, larger program.

The general idea behind our monadic backend is that one can view an imperative program as a sequence of instructions to be executed on some machine---which looks similar to programs written in a stateful monad using Haskell's do-syntax. In fact, a stateful program composed with monadic operations can be directly translated into statements in an imperative language.

% C is perhaps the most commonly used language for writing software in embedded systems and is as such used by the co-design library as well. For hardware descriptions we use the VHDL language, purely based on the fact it is the hardware description language we are most comfortable with. 

As an example of the similarities between monads and imperative programs, consider a software program for reversing an array:

\begin{code}
reverseS :: SArr Int32 -> Software ()
reverseS arr =
  for 0 (len `div` 2) $ \ix -> do
    aix <- getArr arr ix
    ajx <- getArr arr (len - ix - 1)
    setArr arr ix ajx
    setArr arr (len - ix - 1) aix
  where
    len = length arr
\end{code}

\noindent Its type tells us that it takes an array over 32-bit integers as input and produces a software program---notice that the array type \codei{SArr} is prefixed with an \codei{S} in order to show that it is intended to be used with software statements. The return type of the software program is empty as the array is reversed in place.

The implementation of \codei{reverseS} has the look and feel of a imperative program, sans a few syntactical differences, as it iterating over the input array with a for loop and swaps values from the left side with their opposite position on the right. As a result, the translation of \codei{reverseS} to, for example, C code is straightforward: we simply translate each statement to their corresponding statement in C. % We can even translate each statement individually, as monads take care of the program structure.

% \codei{reverseS} makes use of two array operations for reading and writing to an array, \codei{getArr} and \codei{setArr}, which behave as you would expect them to: \codei{getArr} takes an array and an index, and returns the array's value at that index; \codei{setArr} takes an array, an index and a value, and stores the value in the array.

% For each of these indices, \codei{ix}, it reads two values from the array at the leftmost and rightmost places, offset by the index. Having read and stored these two values into the \codei{aix} and \codei{ajx} variables, they are then put back into the array at the opposite place. This process of flipping pairs of values will eventually result in a reversed array when the two indexed values meet in the middle. 

% , as it loops over the first half of the array's indices

While the type of \codei{reverseS} is that of a software function, there's nothing software specific about it. For-loops and arrays are both part of most imperative languages, including VHDL. We could therefore have implemented the reverse function in hardware as well. In fact, we can define a hardware version of the reverse function simply by changing its type, keeping its body intact:

\begin{code}
reverseH :: HArr Int32 -> Hardware ()
reverseH arr = undefined -- same as before.
\end{code}

The fact that we were able to define both the \codei{reverseS} and \codei{reverseH} functions by using the same implementation body hints that having them marked as software and hardware specific programs was unnecessary; we would have be better off keeping the function generic and thus reusable with both languages.

% After all, the function only requires that its implementer support the for-loop and array operations it uses.

Generic functions that can be interpreted as both software and hardware are supported by the co-design library through its use of type classes: classes lets us put additional constraints on a function that says which operations is required by the language that wants to use it. For instance, the reverse function could be given the following type:

% , generic type:

% Classes which enables us to put additional constraints on what classes of operations are necessary in order to implement a function and thus which languages is can be instantiate in. For the reverse function, we could give it the following type:

\begin{code}
reverse :: (Monad m, Arrays m, Control m, TypeM m Int32)
        => Arr m Int32 -> m ()
reverse arr = undefined -- same as before.
\end{code}

\noindent The previous array types of \codei{SArr} and \codei{HArr} are substituted for the more general array type of \codei{Arr}, which is parameterized on the monad \codei{m}. The general idea is that \codei{Arr} will turn into a \codei{SArr} or \codei{HArr} type when \codei{m} is instantiated with their respective monads.

% Having the extra \codei{m} parameter on \codei{Arr} lets the type be used with any monad that supports arrays.

The new, and now generic, function for reversing an array has introduced two new types from our co-design library, namely the \codei{Arrays} and \codei{Control} constraints. These two classes ensure the for-loop and array operations used by the reverse function will be supported and are, at least in part, given by the following interface:

% These two classes ensure that whichever monad the function gets eventually gets instantiated as will support the necessary array and control operations:

\begin{code}
class Monad m => Arrays m where
  type Arr m
  newArr :: TypeM m a => Exp m Length -> m (Arr m a)
  getArr :: TypeM m a => Arr m a -> Exp m Index -> m a
  setArr :: TypeM m a => Arr m a -> Exp m Index -> a -> m ()

class Monad m => Control m where
  for :: (TypeM m a, Integral a) => Exp m a -> Exp m a -> (Exp m a -> m ())
      -> m ()
\end{code}

\noindent These list the operations associated with each class and, in the case of arrays, the array type used with them. Also, notice the new type \codei{Exp} and constraint \codei{TypeM}, representing the expression and type constraint associated with the monad \codei{m}: \codei{TypeM} ensures a type is representable within \codei{m}, and \codei{Exp} references the expression type used with \codei{m}.

% The \codei{TypeM} and \codei{Exp} types introduced here are quite similar to the earlier \codei{Type} and \codei{Exp} types from section~\ref{haskell}. In fact, the latter two types are defined in terms of the general ones but applied to the softare monad, as we used them with examples that were compiled to C code.

While the software and hardware monads both support the above array and control operations, we can also point out groups of operations which are only supported by software but not hardware, and vice versa---like processes in hardware or IO in software---thus forming a hierarchy of classes. Monads still form the base of the hierarchy, but operations intended for either software or hardware branches also require that their monad is an extension of their respective monads.

As an example of language specific functions, we will revisit the FIR filter from section~\ref{haskell}. Reimplementing the filter as a generic program with is straightforward: the types used in the old filter were simply type synonyms for software types, so we only need to update the function's type to make use of generic arrays and monads instead:

\begin{code}
fir :: (Num a, TypeM m a, Arrays m, Control m) => Int -> Arr m a -> Arr m a
    -> m (Arr m a)
fir N b xs = do
  taps <- initArr (replicate N 0)
  ys   <- newArr  (length xs)
  for 0 L $ \ix -> do
    for 1 (lit N) $ \jx -> do
      tmp <- getArr taps (jx - 1)
      setArr taps jx tmp
    x <- getArr xs ix
    setArr taps 0 x
    setArr ys ix (dot b taps)
  return ys
\end{code}

Connecting the FIR filter to a simple main program that supplies an example arrays for its coefficients and input lets us instantiate the code in, for example, the software monad and compile it to C:

\begin{code}
// C code.
\end{code}

While the above filter is suitable for a software implementation, it is perhaps not ideal as a hardware design: signal processing in C is often done with arrays over chunks of the input, while a hardware design makes use of signals and processes to drive a continuous filter. Signals and processes are hardware specific types, so in order to use them, we first change the type of the filter so that its a hardware specific function:

\begin{code}
firH :: (Num a, HType a) => Int -> HArr a -> Signal a
     -> Hardware (Signal a)
\end{code}

% \noindent Note that, in order to make the filter implementation a bit shorter, we given the output signal as an argument to the filter.

Making the change from generic arrays to signals means that we also have to update the function's body in order to reflect its new types. For signals, the difference is that values are now processed one by one instead of chunks, that is, rather that iterating over an input array we will have to process an input signal and react to its changes in value with a process:

\begin{code}
firH N b xs ys = do
  taps <- initArr (replicate N 0)
  ys   <- initSignal 0
  process (xs .: []) $ do
    for 1 (lit N) $ \jx -> do
      tmp <- getArr taps (jx - 1)
      setArr taps jx tmp
    x <- getSignal xs
    setArr taps 0 x
    setSignal ys (dot b taps)
  return ys
\end{code}

\noindent Note that, the arrays used for taps and coefficients are held by signals.

Connecting the hardware filter to a main program body that supplies it with its inputs and compiling it produces the following VHDL design:

\begin{code}
// VHDL code.
\end{code}

\section{Embedded Expressions}
\label{expr}

A language embedding based on monads gives users a representation of statements in an imperative program to work with, but most meaningful programs also include a notion of pure expressions. These expressions contain a combination of one or more values, constants, variables and operators that our library interprets and computes to produce a new value. As an example, consider a function for squaring a software value:

\begin{code}
squareS :: SExp Int32 -> SExp Int32
squareS a = a * a
\end{code}

% \noindent Applying the squaring function to a value of $5$ is equaivalent to the mathematical expression $5*5$ which evaluates to $25$. Expressions are however a deeply embedded type, as mentioned in section~\ref{haskell}, and evaluation therefore is not the only interpretation that they support. For instance, this squaring expressions could just as well be compiled to C code when used inside a software program.

Just as the software programs from section~\ref{program} have a corresponding type used for hardware programs, \codei{SExp} have a corresponding hardware type for expressions called \codei{HExp}:

% The squaring function can be implemented using hardware expressions by simply changing its type:

\begin{stub}
squareH :: HExp Int32 -> HExp Int32
squareH a = a * a
\end{stub}

Looking at the implementation for our hardware and software squaring functions we see that they're identical; both software and hardware support a multiplication operator for their expressions. The expression type only need to support multiplication which, in Haskell, comes from its \codei{Num} class of numerical operations.

% There is no software or hardware specific characteristics in either squaring function,

\begin{code}
square :: (Num (exp a), Type exp a) => exp a -> exp a
square a = a * a
\end{code}

\noindent Note that the type constraint is slightly different from previous functions, as \codei{Type} is used instead of \codei{TypeM}; the former type constraint is designed for use expressions while the latter is used with monads.

In simple expressions, the resulting value is usually one of various primitive types supported by the co-design library, such as signed and unsigned numerical, floating point, and logical; in more elaborate expressions, it can be a complex data type. For example, it is possible to make an expression over a pair of values, and we can define functions over these pairs as well:

\begin{code}
dist :: (SExp Float, SExp Float) -> (SExp Float, SExp Float) -> SExp Float
dist (x1, y1) (x2, y2) = sqrt (dx**2 + dy**2)
  where
    dx = x1 - x2
    dy = y1 - y2
\end{code}

\noindent \codei{dist} computes the distance between two points in a plane, where points are represented as a pair of coordinates. In order to compile \codei{dist}, we need to get its input from somewhere and do something with its output. A convenient way to do this in software is to use its \codei{fget} function to read standard input, \codei{stdin}, and then use \codei{printf} to write the output out into standard output.

\begin{code}
distProg :: Software ()
distProg = do
  a <- fget stdin
  b <- fget stdin
  printf "dist: %d\n" (dist (a, b) (b, a))
\end{code}

Compiling \codei{distProg} produces the following code:

\begin{code}
// C code.
\end{code}

\noindent Note that there are no pairs in the generated C code, as the different coordinates simply become four separate references to the two input variables.

\section{Communicating Components}

The ability to write software, hardware and generic programs that our co-design library means users can easily experiment with different language implementations of their functions. Most interesting heterogeneous programs does however include a mixture of software and hardware fragments, where the different parts communicate with each other. In the kind of FPGAs with embedded systems that we consider, communication is typically done over an AXI4 or AXI4-lite interconnect. 

% Full AXI4 offers a range of interconnects that include variable data and address bus widths, high bandwidth burst and cached transfers, and various other transaction features. The full specification of AXI4 provides great flexibility to users, and provides advanced burst and streaming transactions. For simpler programs, like the examples we have seen so far, there is no real need for such advanced features---although burst writing of arrays is desirable they are usually small enough to not impact performance. A lighter interconnect is therefore also specified by AXI4, called AXI4-lite. This subset of the full specification forgoes the more advanced features for a simpler communication model of writing and reading single pieces of data, one at a time.

Five channels make up the whole AXI4-lite specification: the read and write address channels, the read and write data channels, and the write acknowledge channel. These channels are represented in VHDL as signals, driven by processes that implement the associated handshaking and logic for reading and writing. Signals behave very much like the references found in C, and processes is a kind of function runs automatically once any of its input changes. Both signals and processes are supported by our co-design library, and the whole AXI4-lite interface can in fact be implemented within the library---while the full AXI4 interface could certainly be implemented as well, we have yet to do so.

% A function called \codei{axi_ligth} takes a hardware program and hooks it up to an AXI4-lite interconnect, and the wrapped hardware component can then be compiled to VHDL and loaded into a synthesis tool like Vivado, which will turn it into a physical design that can be put onto the FPGA.

With the ability to wrap our hardware programs in an AXI4-lite interface, we can create a stand-alone component that, when loaded into a synthesis tool like Vivado~\cite{feist2012}, results in a physical design that can be put onto an FPGAs logic blocks. With a physical component on the hardware, its possible to gets its address, which can then be used from the software side to access the component through memory-mapped I/O. In the co-design library, this is achieved with the \codei{mmap} function:

\begin{code}
mmap :: String -> Component a -> Software (Pointer (Soften a))
\end{code}

Having memory-mapped a component causes them to share address space with the memory of whatever software program they are running in. So, the components can monitor a processors address buss and, whenever an address for component is accessed, they forward the request to the address component. That is, the shared address space means that a component can be reached by writing to and reading from regular pointers. Before we can do that however, we first ``soften'' its type and translate, for example, signals into references:

% The translation of a component's type, which expects signals as input and output, into a software type, that uses references instead of signals, is done by the \codei{Soften} translation:

\begin{code}
type family Soften a where
  Soften (Signal a -> b) = Ref (SExp a) -> Soften b
\end{code}

% \codei{mmap} takes two arguments: an address and a signature of the hardware component. Signatures are regular programs coupled with a description of their type that can be viewed from within Haskell, something we cannot normally do. The result is of \codei{mmap} is a pointer to the component with a type that has been translated to make use of software constructs like references instead of the signals used in hardware. This translation is handled by a type family, which describes how the hardware type should be interpreted as software instead:

With a hardware component placed onto the FPGA and memory-mapped into software, we can call the component by fully applying its software pointer to its arguments:

\begin{code}
call :: Pointer a -> Arguments a -> Software ()
\end{code}

Text.

\begin{code}
-- Example code.
\end{code}


\end{document}
