%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%       oe    
%     .@88    
% ==*88888    
%    88888    
%    88888    
%    88888    
%    88888    
%    88888    
%    88888    
%    88888    
% '**%%%%%%** 
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[../paper.tex]{subfiles}
\begin{document}

\chapter{Introduction}
\label{intro}

Embedded systems are, in brief, any computer system that is part of a larger system but relies on its own microprocessor. It is embedded as part of a larger machine to solve a particular task, and often does so under memory and real-time constraints. Embedded systems have been have been around for decades, and still control many devices in common use today~\cite{barr2006}. For example, modern cars contain a number of embedded systems, each controlling a small function of the car; one system might control the brakes, while another displays information to the dashboard. In most cases, these embedded sub-systems are all connected together in a network. 

Developing software for embedded systems, in most cases, requires good knowledge about the hardware on which the software is supposed to run. This is because embedded systems are typically designed with a task in mind and consists of the most cost-effective hardware that meets the performance requirements. Developers must therefore ensure that not only are their computations efficient, but also take full advantage of the custom hardware; every line of code counts.

As important as computational power is for embedded systems, limiting their power consumption presents an equally important issue in their architectural design~\cite{mudge2001}---the trend of trading power for performance cannot continue indefinitely. Containing the growth in power requires architectural improvements, with specialized computing for specialized tasks.

Heterogeneous computing represents an interesting development towards the goal of energy efficient computing, and refers to systems making use of more than one kind of processor. These heterogeneous systems gain their performance and energy efficiency not just by combining several processors, but rather by incorporating different kinds of co-processors that provide specialized processing capabilities to handle a particular task. Their efficiency and computational power comes at a cost of increased programming burden in terms of code complexity and portability. Hardware specific code is interleaved with software code to describe its various components and to handle any communication between co-processors.

A substantial amount of research has gone into addressing the challenges of programming for embedded heterogeneous systems, opening them up for programmers without a background in hardware or embedded system design. Hardware description languages are however still the most commonly used tools, together with C dialects for specific co-processors. While such low-level languages are good for extracting maximum performance from a processor, they provide little to no abstractions for alleviate the task of programming for heterogeneous systems.

Another group of languages whom I believe show great promise in describing hardware designs are the functional languages. Higher-order functional languages in particular, where hardware descriptions are first-class objects, offer a particularly useful abstraction mechanism~\cite{baaij2010, bjesse1998, gill2010}. For instance, a higher-order functional language allows for computations to be passed around as first-class objects. Smaller functions can then be assembled in a modular way into a larger applications. Also, thanks to the powerful type-systems of functional languages, it is possible to precisely record a function's dependencies in its type; functions can depend on the smaller functions they use rather the entire domain they're part of.

Despite the aforementioned benefits of functional programming languages, they are rarely considered for embedded system development. One reason for their low adaptation is that some features, while facilitating the design of hardware descriptions, also makes it difficult to give performance guarantees and resource bounds, especially so for functional languages with lazy evaluation.

This thesis presents the first steps towards a functional programming language for embedded heterogeneous systems. Instead of taking on the full challenge of heterogeneous programming head on, we are currently exploring a more modest approach: develop a hardware software co-design language, embed it in Haskell, and see how far we can get. The language is staged and utilizes the rich type system of its host language to facilitate design exploration. Furthermore, we have developed a vector and a signal processing language to accompany the co-design language.

As an example of our co-design language, consider a dot product, also known as a scalar product. The dot product is an algebraic operation that takes two vectors of equal length and returns the sum of the products of the corresponding entries of the two vectors:

\begin{equation}
a \cdot b = \sum_{i=1}^{n}a_{i}b_{i} = a_{1}b_{1} + a_{2}b_{2} + \cdots + a_{n}b_{n}
\end{equation}

With an imperative language like C the dot product's result could be computed with a single for-loop that iterates over the two input arrays and calculates the sum of their products, one pair at a time. Such a sequential solution can be implemented in the co-design language as well:

\begin{code}
dotSeq :: Arr Int32 -> Arr Int32 -> Program (Exp Int32)
dotSeq x y = do
  sum <- initRef 0
  for 0 (min (length x) (length y)) $ \ix -> do
    a <- getArr x ix
    b <- getArr y ix
    modifyRef sum $ \s -> s + a * b
  getRef sum
\end{code}

While the above function is faithful to its corresponding implementation in C, the low-level design has forced us to focus on implementation details rather than the mathematical specification of the dot product. In this situation, where the function can be succinctly expressed as a sum over products, we would be better off using the vector language instead. In fact, the same dot product can be implemented with vectors in a single line:

\begin{code}
dotVec :: Vec Int32 -> Vec Int32 -> Program (Exp Int32)
dotVec x y = sum (zipWith (*) x y)
\end{code}

At this point we should note that neither version of the dot functions so far mentions any software or hardware specifics and, as such, the functions could be realized in both languages. Lets assume we wish to put \codei{dotVec} onto hardware. Before we can offload the function, we must first give it a signature that describes its inputs and output. For the dot-product, this means that we declare two input arrays with and a single output:

\begin{code}
dotSig :: Signature (Arr Int32 -> Arr Int32 -> Sig Int32)
dotSig = inputVec 4 $ \x -> inputVec 4 $ \y -> returnVal $ dotVec x y
\end{code}

The signature of a component lets us inspect a type from within Haskell and, for example, hook it up to an AXI4-lite interconnect which lets us reach the component from software through memory-mapped I/O. This process causes the component to share its address space with the memory of whatever software program they are running in, that is, the component can be reached by simply reading and writing to pointers into its address. The co-design language provides a \codei{compileAXI4lite} function that produces a synthesizable interconnect for a given function's signature.

After the dot-product has been hooked up to an AXI4-lite interconnect, synthesized and put onto hardware, we can write a small software program that interacts with the component and prints its result:

\begin{code}
program :: Software ()
program x y = do
  dot <- mmap "0x43C00000" dotSig
  xs  <- initArray [1,2,3,4]
  ys  <- initArray [5,6,7,8]
  r   <- newRef
  call dot (xs .: ys .: r .: nil)
  res <- getRef r
  printf "sum: %d" res
\end{code}

\noindent Firstly, the software program brings our component into scope by calling the memory-mapping function, \codei{mmap}, with the physical address and signature of the component. Then we then declare two arrays and a reference to hold the output and input values of the component. Finally, we call the component using \codei{call} with our arrays and reference as arguments. The result is then read from the reference and printed to standard output.

\end{document}
