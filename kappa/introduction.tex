%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%       oe    
%     .@88    
% ==*88888    
%    88888    
%    88888    
%    88888    
%    88888    
%    88888    
%    88888    
%    88888    
% '**%%%%%%** 
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[../paper.tex]{subfiles}
\begin{document}

\chapter{Introduction}
\label{intro}

An embedded system is, in brief, any computer system that is part of a larger system but relies on its own microprocessor. It is embedded as part of a larger machine to solve a particular task, and often does so under memory and real-time constraints. Embedded systems have been have been around for decades, and still control many devices in common use today~\cite{barr2006}. For example, modern cars contain a number of embedded systems, each controlling a small function of the car; one system might control the brakes, while another displays information to the dashboard. In most cases, these embedded sub-systems are all connected together in a network. 

Developing software for embedded systems, in most cases, requires good knowledge about the hardware on which the software is supposed to run. This is because an embedded system is typically designed with a particular task in mind and consists of the most cost-effective hardware that meets the performance requirements. Developers must therefore ensure that not only are their computations efficient, but also take full advantage of the custom hardware; every line of code counts.

As important as computational power is for embedded systems, limiting their power consumption presents an equally important issue in their architectural design~\cite{mudge2001}---the trend of trading power for performance cannot continue indefinitely. Containing the growth in power requires architectural improvements, with specialized computing for specialized tasks.

Heterogeneous computing represents an interesting development towards the goal of energy efficient computing, and refers to systems making use of more than one kind of processor. These heterogeneous systems gain their performance and energy efficiency not just by combining several processors, but rather by incorporating different kinds of co-processors that provide specialized processing capabilities to handle a particular task. Their efficiency and computational power comes at a cost of increased programming burden in terms of code complexity and portability. Hardware specific code is interleaved with software code to describe its various components and to handle any communication between co-processors.

A substantial amount of research has gone into addressing the challenges of programming for embedded heterogeneous systems, opening them up for programmers without a background in hardware or embedded system design. Hardware description languages are however still the most commonly used tools, together with C dialects for specific co-processors. While such low-level languages are good for extracting maximum performance from a processor, their portability is severely limited; design exploration in low-level languages is tedious at best and moving programs between software and hardware is often a major undertaking.

Another group of languages that I believe show great promise in describing hardware designs are the functional languages. Higher-order functional languages in particular offer an especially useful abstraction mechanism~\cite{baaij2010, bjesse1998, gill2010}, through higher-order functions and lazy evaluation. These features allow for functions to be treated as first-class objects, where larger applications are constructed by composing such functions in a modular fashion. Only the relevant parts of these smaller functions will show up in the generated source code. Furthermore, the type-system and type classes of functional languages makes it possible to precisely record a function's operational dependencies in its type---functions can depend on the operations they use rather then the software or hardware component they're designed for.

Despite the aforementioned benefits of functional programming languages, they are rarely considered for embedded system development. One reason for their low adaptation is that its difficult to give performance guarantees and resource bounds.

This thesis presents the first steps towards a functional programming language for embedded heterogeneous systems. Instead of taking on the full challenge of heterogeneous programming head on, we are currently exploring a more modest approach: develop a hardware software co-design language, embed it in Haskell, and see how far we can get. The language is staged and utilizes the rich type system of its host language to facilitate design exploration. Furthermore, we have developed a vector and a signal processing language to accompany the co-design language.

As an example of our co-design language, consider a dot product, also known as a scalar product. The dot product is an algebraic operation that takes two vectors of equal length and returns the sum of the products of the corresponding entries of the two vectors:

\begin{equation}
a \cdot b = \sum_{i=1}^{n}a_{i}b_{i} = a_{1}b_{1} + a_{2}b_{2} + \cdots + a_{n}b_{n}
\end{equation}

With an imperative language like C the dot product's result could be computed with a single for-loop that iterates over the two input arrays and calculates the sum of their products, one pair at a time. Such a sequential solution can be implemented in the co-design language as well:

\begin{code}
dotSeq :: Arr Int32 -> Arr Int32 -> Program (Exp Int32)
dotSeq x y = do
  sum <- initRef 0
  for 0 (min (length x) (length y)) $ \ix -> do
    a <- getArr x ix
    b <- getArr y ix
    modifyRef sum $ \s -> s + a * b
  getRef sum
\end{code}

While the above function is faithful to its corresponding implementation in C, the low-level design has forced us to focus on implementation details rather than the mathematical specification of the dot product. In this situation, where the function can be succinctly expressed as a sum over products, we would be better off using the vector language instead. In fact, the same dot product can be implemented with vectors in a single line:

\begin{code}
dotVec :: Vec Int32 -> Vec Int32 -> Program (Exp Int32)
dotVec x y = sum (zipWith (*) x y)
\end{code}

At this point we should note that neither version of the dot product mentions any software or hardware specifics and, as such, can be realized in both software and hardware. The dot product can be compiled to software as it is. If we want to put it onto hardware instead, we must first give it a signature that lists its two inputs and output:

\begin{code}
dotSig :: Component (Arr Int32 -> Arr Int32 -> Sig Int32)
dotSig = inputVec 4 $ \x -> inputVec 4 $ \y -> returnVal $ dotVec x y
\end{code}

\noindent The signature of a component lets our compiler inspect its input and output ports to, for example, compile it to a hardware design or hook it up to an AXI4-lite interconnect---a standard for communication between software and hardware components.

Having wrapped our \codei{dotSig} component in an AXI4-lite interconnect and then put it onto hardware, its possible to reach it from software through memory-mapped I/O. The general idea is that a memory-mapped component will share its address space with the software program, that is, a memory-mapped hardware component can be reached from software by simply reading and writing to regular pointers. As an example, we write a small software program that calls \codei{dotSig} and prints its result:

\begin{code}
program :: Software ()
program x y = do
  dot <- mmap "0x43C00000" dotSig
  xs  <- initArray [1,2,3,4]
  ys  <- initArray [5,6,7,8]
  r   <- newRef
  call dot (xs .: ys .: r .: nil)
  res <- getRef r
  printf "sum: %d" res
\end{code}

The above software program first brings our \codei{dotSig} hardware component into scope by calling the memory-mapping function \codei{mmap} with the components physical address---which we acquired during synthesis---and signature. Two arrays are then declared, one for each input of the hardware component, and a reference for its output. Lastly, the component is called with an argument list that matches its signature, and its result is read from the reference that holds it and printed to standard output.

\end{document}
