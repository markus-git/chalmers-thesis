%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%         xeee    
%        d888R    
%       d8888R    
%      @ 8888R    
%    .P  8888R    
%   :F   8888R    
%  x"    8888R    
% d8eeeee88888eer 
%        8888R    
%        8888R    
%     "*%%%%%%**~ 
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[../main.tex]{subfiles}
\begin{document}

\chapter{Signal processing}

For example, the the FIR filter can be expressed quite nicely using signals. Before we can do that however, we first define three helper functions that implement the three majort components of the filter: a number of successive unit delays, multiplication with coefficients and a summation.

\begin{code}
sums :: (Num a, Type a) => [Sig a] -> Sig a
sums as = foldr1 (+) as

muls :: (Num a, Type a) => [Exp a] -> [Sig a] -> [Sig a]
muls as bs = zipWith (*) (map repeat as) bs

dels :: Type a => Exp a -> Sig a -> [Sig a]
dels e as = iterate (delay a) as
\end{code}

\noindent Addition and multiplication are overloaded operators from Haskell's \codei{Num} class which are lifted to operate element-wise over signals. The list operations \codei{foldr1}, \codei{zipWith}, and \codei{iterate} are all part of Haskell's standard functions for lists.

A FIR filter can now be expressed in the signal library as:

\begin{code}
fir :: (Num a, Type a) => [Exp a] -> Sig a -> Sig a
fir coeff = sums . muls coeff . dels 0
\end{code}

\noindent Which is quite close to the filter's mathematical representation.

\todo{Compile and show generated source code, make sure to mention the buffers it has generated.}

\begin{code}
// the C code.
\end{code}

\end{document}
